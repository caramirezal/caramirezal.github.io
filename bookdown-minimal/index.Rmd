---
title: "IRTG COURSE: INTRODUCTION TO R"
author: "Carl Herrmann & Carlos Ramirez"
site: bookdown::bookdown_site
date: "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: book
output:
  bookdown::gitbook: default
  #bookdown::pdf_book: default
  bookdown::pdf_book:
    citation_package: biblatex
---


```{r, setup, include=FALSE}
knitr::opts_chunk$set(
        warning = FALSE, 
        message = FALSE,
        cache = FALSE,
        fig.align='center'
)

```


# scRNA-Seq Course Syllabus {#intro}


We will use available data from 10X genomics of Peripheral Blood Mononuclear cells (PBMC). In order
to speed up the process only a subset of 500 cells are going to be processed here. Here, we will
perform the following tasks:

* Definition of a Seurat object from a matrix of counts
* Quality Control (QC) of the cell samples
* Filtering
* Dimensional reduction
* Clustering
* Differential expression
* Visualization of markers


## Single Cell Sequencing

Single cell sequencing (scRNA-Seq) technologies arise from bulk counterparts with 
the aim of refining gene expression profiles. Previous bulk Sequencing offered 
averaged quantifications of gene expression in samples. In some contexts, for 
example, when studying cell type specificity or the heterogeneity in tumours is 
important to dissect patterns in cell subpopulations.

The following image illustrates the development of scRNA-Seq technologies
and the number of cells that can be analyzed with each technology. In this 
course we will not cover this topic, but instead we will take a hands on
approach and jump directly to the analysis of scRNA-Seq data. However, the 
analysis that we show next are applied downstream to libraries construction
and sequencing and are therefore platform agnostic.


![**Single Cell Sequencing Platforms**: Date of development *vs* number of cells analyzed by each technology.](figures/moores-law.png)

Image is taken from [Svensson V et al, 2017](https://arxiv.org/abs/1704.01379).


## Quantifying gene expression in single cells


Genes are expressed in cells by the synthesis of mRNA molecules. Quantification of gene expression
in single cells consists of counting and mapping sequenced reads to each gene in each cell. The 
outcome of this process is a count matrix, which is a discrete matrix of integers corresponding
to the number of RNA molecules associated to each gene and cell. The count matrix usually has 
genes as rows and cells in columns. 

In the next lines we will load the matrix of UMI counts into a variable called `pbmc.mtx`. 


```{r, loading_dataset}
## Dependencies
library(rmarkdown)

set.seed(333)

## Loading example data
pbmc_url  <- 'https://github.com/caramirezal/caramirezal.github.io/raw/master/bookdown-minimal/data/pbmc_10X_500_cells.mtx.rds'
pbmc.mtx <- readRDS(url(pbmc_url))
```


As can be seen from the output of the function `dim(pbmc.mtx)` the matrix contains `r nrow(pbmc.mtx)` rows (genes) and `r ncol(pbmc.mtx)` columns (cells). 


```{r, matrix dimensions}
dim(pbmc.mtx)
```


To have a glimpse of the appearance of this matrix we print the first 5 rows and first 5 columns. It can
be seen that the matrix object is a particular array called sparse Matrix. These types of matrices are 
specially efficient to store numerical arrays which are very sparse (full of zeroes) as is the case
for single cell count matrices data.


```{r, matrix_top_rows_cols}
pbmc.mtx[1:5, 1:5]
```

We can start from different types of arrays apart from sparse matrices as data frames or hd5 
objects just to give some examples. The format in which the matrix is provided might also vary from 
excel files, tsv, csv, rds, etc. Usually this formats can be converted into each other, however, the
methods for such transformation are so different and specific that we cannot covered here.



